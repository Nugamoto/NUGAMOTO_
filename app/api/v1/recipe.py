"""FastAPI router exposing the */recipes* endpoints."""

from __future__ import annotations

from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Query, Response, status
from sqlalchemy.orm import Session

from app.core.dependencies import get_db
from app.crud import recipe as crud_recipe
from app.schemas.recipe import (
    RecipeCreate,
    RecipeNutritionCreate,
    RecipeNutritionRead,
    RecipeNutritionUpdate,
    RecipeRead,
    RecipeSearchParams,
    RecipeSummary,
    RecipeUpdate,
    RecipeWithDetails,
)

router = APIRouter(prefix="/recipes", tags=["Recipes"])


# ------------------------------------------------------------------ #
# Recipe Routes                                                      #
# ------------------------------------------------------------------ #

@router.post(
    "/",
    response_model=RecipeWithDetails,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new recipe",
)
def create_recipe(
        recipe_data: RecipeCreate, db: Session = Depends(get_db)
) -> RecipeWithDetails:
    """Create a new recipe with ingredients, steps, and optional nutrition.

    Recipes can be created manually by users or generated by AI services.
    The AI relationship is managed through the AIModelOutput model separately.

    Args:
        recipe_data: Validated recipe payload including all related data.
        db: Injected database session.

    Returns:
        The newly created recipe with all related data.

    Raises:
        HTTPException:
            * 400 if referenced food items or user do not exist.
            * 400 if validation fails (duplicate ingredients, invalid step sequence).

    Note:
        This endpoint is designed for both manual recipe creation and
        AI-generated recipe storage. The is_ai_generated flag should be
        set to True when called by AI services.
    """
    try:
        db_recipe = crud_recipe.create_recipe(db, recipe_data)
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc

    # Fetch with all details for response
    recipe_with_details = crud_recipe.get_recipe_with_details(db, db_recipe.id)
    return RecipeWithDetails.model_validate(recipe_with_details, from_attributes=True)


@router.get(
    "/",
    response_model=list[RecipeRead],
    status_code=status.HTTP_200_OK,
    summary="Get all recipes with optional filtering",
)
def get_all_recipes(
        title_contains: Optional[str] = Query(None, description="Filter by title containing text"),
        is_ai_generated: Optional[bool] = Query(None, description="Filter by AI generation status"),
        created_by_user_id: Optional[int] = Query(None, description="Filter by creator user ID"),
        has_nutrition: Optional[bool] = Query(None, description="Filter by nutrition data presence"),
        max_kcal: Optional[float] = Query(None, description="Maximum calories filter"),
        min_protein_g: Optional[float] = Query(None, description="Minimum protein filter"),
        skip: int = Query(0, ge=0, description="Number of records to skip"),
        limit: int = Query(100, ge=1, le=1000, description="Maximum number of records to return"),
        db: Session = Depends(get_db),
) -> list[RecipeRead]:
    """Retrieve all recipes with optional search and filtering.

    Supports pagination and various filter criteria including nutrition-based filters.

    Args:
        title_contains: Optional text filter for recipe titles.
        is_ai_generated: Optional filter for AI-generated recipes.
        created_by_user_id: Optional filter by creator user.
        has_nutrition: Optional filter for recipes with nutrition data.
        max_kcal: Optional maximum calorie filter.
        min_protein_g: Optional minimum protein filter.
        skip: Number of records to skip for pagination.
        limit: Maximum number of records to return.
        db: Injected database session.

    Returns:
        A list of recipes matching the criteria.
    """
    search_params = RecipeSearchParams(
        title_contains=title_contains,
        is_ai_generated=is_ai_generated,
        created_by_user_id=created_by_user_id,
        has_nutrition=has_nutrition,
        max_kcal=max_kcal,
        min_protein_g=min_protein_g,
    )

    recipes = crud_recipe.get_all_recipes(db, search_params, skip, limit)
    return [RecipeRead.model_validate(recipe, from_attributes=True) for recipe in recipes]


@router.get(
    "/summary",
    response_model=RecipeSummary,
    status_code=status.HTTP_200_OK,
    summary="Get recipe statistics summary",
)
def get_recipe_summary(db: Session = Depends(get_db)) -> RecipeSummary:
    """Retrieve summary statistics for all recipes.

    Args:
        db: Injected database session.

    Returns:
        Summary statistics including counts by type and nutrition status.
    """
    summary = crud_recipe.get_recipe_summary(db)
    return summary


@router.get(
    "/{recipe_id}",
    response_model=RecipeWithDetails,
    status_code=status.HTTP_200_OK,
    summary="Get recipe details",
)
def get_recipe(recipe_id: int, db: Session = Depends(get_db)) -> RecipeWithDetails:
    """Retrieve a single recipe with all related data.

    Includes ingredients with food item details, ordered steps,
    nutrition information, and creator details.

    Args:
        recipe_id: Primary key of the recipe.
        db: Injected database session.

    Returns:
        The complete recipe with all related data.

    Raises:
        HTTPException: 404 if the recipe does not exist.
    """
    recipe = crud_recipe.get_recipe_with_details(db, recipe_id)
    if recipe is None:
        raise HTTPException(status_code=404, detail="Recipe not found.")

    return RecipeWithDetails.model_validate(recipe, from_attributes=True)


@router.put(
    "/{recipe_id}",
    response_model=RecipeRead,
    status_code=status.HTTP_200_OK,
    summary="Update a recipe",
)
def update_recipe(
        recipe_id: int,
        recipe_data: RecipeUpdate,
        db: Session = Depends(get_db),
) -> RecipeRead:
    """Update an existing recipe (partial update).

    Note: This only updates basic recipe fields. For ingredients, steps,
    and nutrition, use the dedicated endpoints.

    Args:
        recipe_id: Primary key of the recipe to update.
        recipe_data: Partial recipe payload.
        db: Injected database session.

    Returns:
        The updated recipe.

    Raises:
        HTTPException:
            * 404 if the recipe does not exist.
            * 400 if user validation fails.
    """
    try:
        updated_recipe = crud_recipe.update_recipe(db, recipe_id, recipe_data)
    except ValueError as exc:
        if "Recipe not found" in str(exc):
            raise HTTPException(status_code=404, detail=str(exc)) from exc
        else:
            raise HTTPException(status_code=400, detail=str(exc)) from exc

    return RecipeRead.model_validate(updated_recipe, from_attributes=True)


@router.delete(
    "/{recipe_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete a recipe",
)
def delete_recipe(
        recipe_id: int,
        db: Session = Depends(get_db),
) -> Response:
    """Delete a recipe by primary key.

    All related ingredients, steps, and nutrition will be automatically
    deleted due to cascade configuration.

    Args:
        recipe_id: ID of the recipe to delete.
        db: Injected database session.

    Returns:
        Response with 204 status code.

    Raises:
        HTTPException: 404 if the recipe does not exist.
    """
    try:
        crud_recipe.delete_recipe(db, recipe_id)
    except ValueError as exc:
        raise HTTPException(status_code=404, detail=str(exc)) from exc

    return Response(status_code=status.HTTP_204_NO_CONTENT)


# ------------------------------------------------------------------ #
# Recipe Nutrition Routes                                            #
# ------------------------------------------------------------------ #

@router.post(
    "/{recipe_id}/nutrition",
    response_model=RecipeNutritionRead,
    status_code=status.HTTP_201_CREATED,
    summary="Add or update nutrition information",
)
def create_or_update_recipe_nutrition(
        recipe_id: int,
        nutrition_data: RecipeNutritionCreate,
        db: Session = Depends(get_db),
) -> RecipeNutritionRead:
    """Add or update nutrition information for a recipe.

    If nutrition data already exists, it will be updated with the new values.

    Args:
        recipe_id: Primary key of the recipe.
        nutrition_data: Validated nutrition payload.
        db: Injected database session.

    Returns:
        The created or updated nutrition information.

    Raises:
        HTTPException: 404 if the recipe does not exist.

    Note:
        This endpoint can be used by AI services to add calculated
        nutrition information to recipes, or by users to manually
        enter nutrition data.
    """
    try:
        nutrition = crud_recipe.create_or_update_recipe_nutrition(
            db, recipe_id, nutrition_data
        )
    except ValueError as exc:
        raise HTTPException(status_code=404, detail=str(exc)) from exc

    return RecipeNutritionRead.model_validate(nutrition, from_attributes=True)


@router.put(
    "/{recipe_id}/nutrition",
    response_model=RecipeNutritionRead,
    status_code=status.HTTP_200_OK,
    summary="Update nutrition information",
)
def update_recipe_nutrition(
        recipe_id: int,
        nutrition_data: RecipeNutritionUpdate,
        db: Session = Depends(get_db),
) -> RecipeNutritionRead:
    """Update existing nutrition information for a recipe (partial update).

    Args:
        recipe_id: Primary key of the recipe.
        nutrition_data: Validated partial nutrition payload.
        db: Injected database session.

    Returns:
        The updated nutrition information.

    Raises:
        HTTPException: 404 if the recipe or nutrition does not exist.
    """
    try:
        nutrition = crud_recipe.update_recipe_nutrition(db, recipe_id, nutrition_data)
    except ValueError as exc:
        raise HTTPException(status_code=404, detail=str(exc)) from exc

    return RecipeNutritionRead.model_validate(nutrition, from_attributes=True)


@router.delete(
    "/{recipe_id}/nutrition",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete nutrition information",
)
def delete_recipe_nutrition(
        recipe_id: int,
        db: Session = Depends(get_db),
) -> Response:
    """Remove nutrition information from a recipe.

    Args:
        recipe_id: Primary key of the recipe.
        db: Injected database session.

    Returns:
        Response with 204 status code.

    Raises:
        HTTPException: 404 if the nutrition does not exist.
    """
    try:
        crud_recipe.delete_recipe_nutrition(db, recipe_id)
    except ValueError as exc:
        raise HTTPException(status_code=404, detail=str(exc)) from exc

    return Response(status_code=status.HTTP_204_NO_CONTENT)


# ------------------------------------------------------------------ #
# AI Integration Routes                                              #
# ------------------------------------------------------------------ #

@router.get(
    "/suggestions/by-ingredients",
    response_model=list[RecipeRead],
    status_code=status.HTTP_200_OK,
    summary="Get recipe suggestions based on available ingredients",
)
def get_recipe_suggestions_by_ingredients(
        food_item_ids: list[int] = Query(..., description="List of available food item IDs"),
        min_match_percentage: float = Query(0.7, ge=0.0, le=1.0, description="Minimum ingredient match percentage"),
        db: Session = Depends(get_db),
) -> list[RecipeRead]:
    """Get recipe suggestions based on available ingredients.

    This endpoint is designed for AI integration to suggest recipes
    based on current kitchen inventory.

    Args:
        food_item_ids: List of food item IDs currently available.
        min_match_percentage: Minimum percentage of ingredients that must be available.
        db: Injected database session.

    Returns:
        A list of recipes that can be made with available ingredients,
        ordered by ingredient match percentage.

    Note:
        This endpoint can be integrated with inventory management to suggest
        recipes based on what's currently available in the kitchen. Perfect
        for AI meal planning and reducing food waste.
    """
    if not food_item_ids:
        return []

    recipes = crud_recipe.get_recipes_by_available_ingredients(
        db, food_item_ids, min_match_percentage
    )
    return [RecipeRead.model_validate(recipe, from_attributes=True) for recipe in recipes]


@router.get(
    "/ai-generated",
    response_model=list[RecipeWithDetails],
    status_code=status.HTTP_200_OK,
    summary="Get recent AI-generated recipes",
)
def get_ai_generated_recipes(
        limit: int = Query(50, ge=1, le=100, description="Maximum number of recipes to return"),
        db: Session = Depends(get_db),
) -> list[RecipeWithDetails]:
    """Get recently created AI-generated recipes.

    This endpoint can be used to analyze AI recipe generation patterns
    and improve future AI prompts.

    Args:
        limit: Maximum number of recipes to return.
        db: Injected database session.

    Returns:
        A list of AI-generated recipes with full details,
        ordered by creation time (newest first).

    Note:
        This endpoint is useful for monitoring AI recipe generation
        quality and gathering data for prompt optimization.
    """
    recipes = crud_recipe.get_ai_generated_recipes(db, limit)
    return [
        RecipeWithDetails.model_validate(recipe, from_attributes=True)
        for recipe in recipes
    ]
